goal is to have a diagram of the class with dependencies:

statements or segments of code to be analysed:
	namespaces
	extends 
	interfaces 
	functions atributes
	functions return values

we don't care if a class is used in a function (yet) because:
1) we might have to dig too deep into the code for that to happen (what about macros and anonymous functions?)
2) we could use the "use" statement to get the hints from source


a list of of GENERAL operations I want to implement:

1) get the list of .php files from a directory (DONE as microtest)
2) get the content from a source (DONE)
3) create objects for each type of statement
4) add those objects into a ClassDiagram object as container
5) using the container, discover the relationship among them.
6) locate the appropiate object "level" among classes hierarchy (superclases and parent goes to the top level)


6) once I have the previous step, create a "tree" for each group of related nodes.
7) "draw" internally how the diagram should look like.
	ie: 
	how many heads (parent classes)
	how deep will be  (levels of subclasses)
	how width (maximum number of subclases at the same deep level on a given class tree)
8) separate "trees" based on each others width. This involves creating some sort of grid.
9) create the diagram using straight arrows?
10) color the boxes based on namespace


20200514 0037 GMT-3 
what bothers me is the fact I'm taking some big steps and selecting the next test becomes hard. And the resulting code felt funny as if I was cheating. So I decided to go back a bit.


20200515 0026 GMT-3
renamed "clase" as "class_"
created "interface_"
Trying to apply the KISS rule, refactoring will show me the way later.

20200515 0127 GMT-3
idea: create a vectorial canvas to allow us to move arround the objects ?
idea2: create an Application object with the main methods like: 
	select_dir
	scan_dir
	read_sources
	create_objects
	resolve_relationships

and so on

20200515 1849 GMT-3
decided to go for the App class, it will guide the things need to be completed from now on.

20200616 0109 GMT-3
so far so good. Made it up to the interfaces extends. Sections of the code are a bit messy yet.
Now I'm considering building trees based on the classes with no parents classes since each class can have no more than one parent. Then I could simply scan each class to see where it belongs and creating the class tree. Probably with a recursive function.

20200516 0239
made the levels hierarch. What left's me wonder if there's really a need to link objects among them.

I call "level" the horizontal ruler of the future diagram grid. Parents classes should be on level 0. Direct  subclases from the parent on level 1, and so on.

"Tree" would be the vertial aligment of a set of classes. 

20200517 

<deleted bc it was useless babling>
	
20200519
after two days rushing a bit to get the text tree I realized I was representing a two dimensials problem into a one-dimensional solution. At least using the same method.
So, *my guess* is the best way to solve the problem with multiple interfaces in multiple classes is to use a virtual grid to place the classes based on a similar criteria like I did on get_tree()

I only need to look for elements who has no parents first and place them at the top, then everything else goes under them. 
Expanding the grid horizontally is done by adding columns to the left of the item I want to "move" 

so, the grid should have two types of items:
1) elements (classes/interfaces) 
2) arrows (dependencies/implementations)


20200522
to the last comment I must add:
1) once the trees are created, its important to calculate the width and height of each of them
the sum of all of them will give me the size of the diagram needed.

I'm also considering creating separated images for each tree and just one for orphan elements.

2) the problem with overlapping nodes and moving nodes around as needed. seems important to evaluate the width of each node (I think I already did that). By doing that I could reserve space among elements.

Another element to keep in mind, horizal space needed by a node.

So, if I have a tree o

